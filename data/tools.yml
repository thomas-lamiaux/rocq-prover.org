tools:
  - name: coq.8.20.1
    source: https://rocq-prover.org/" rel="nofollow
    license: https://spdx.org/licenses/LGPL-2.1-only.html
    synopsis:  The Coq Proof Assistant
    description: >
      Coq is a formal proof management system. It providesa formal language to write mathematical definitions, executablealgorithms and theorems together with an environment forsemi-interactive development of machine-checked proofs.Typical applications include the certification of properties ofprogramming languages (e.g. the CompCert compiler certificationproject, or the Bedrock verified low-level programming library), theformalization of mathematics (e.g. the full formalization of theFeit-Thompson theorem or homotopy type theory) and teaching.
    lifecycle: base
  - name: dune-configurator.3.16.1
    source: https://github.com/ocaml/dune
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Helper library for gathering system configuration
    description: >
      dune-configurator is a small library that helps writing OCaml scripts thattest features available on the system, in order to generate config.hfiles for instance.Among other things, dune-configurator allows one to:- test if a C program compiles- query pkg-config- import #define from OCaml header files- generate config.h file
    lifecycle: base
  - name: dune.3.16.1
    source: https://github.com/ocaml/dune
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Fast, portable, and opinionated build system
    description: >
      Dune is a build system that was designed to simplify the release ofJane Street packages. It reads metadata from \dune\ files following avery simple s-expression syntax.Dune is fast, has very low-overhead, and supports parallel builds onall platforms. It has no system dependencies; all you need to builddune or packages using dune is OCaml. You don'apos;t need make or bashas long as the packages themselves don'apos;t use bash explicitly.Dune is composable; supporting multi-package development by simplydropping multiple repositories into the same directory.Dune also supports multi-context builds, such as building againstseveral opam roots/switches simultaneously. This helps maintainingpackages across several versions of OCaml and gives cross-compilationfor free.
    lifecycle: base
  - name: coqide.8.20.1
    source: https://rocq-prover.org/" rel="nofollow
    license: https://spdx.org/licenses/LGPL-2.1-only.html
    synopsis:  The Coq Proof Assistant --- GTK3 IDE
    description: >
      Coq is a formal proof management system. It providesa formal language to write mathematical definitions, executablealgorithms and theorems together with an environment forsemi-interactive development of machine-checked proofs.This package provides the CoqIDE, a graphical user interface for thedevelopment of interactive proofs.
    lifecycle: ide
  - name: vscoq-language-server.2.2.3
    source: https://github.com/rocq-prover/vscoq
    license: https://spdx.org/licenses/MIT.html
    synopsis:  VSCoq language server
    description: >
      LSP based language server for Coq and its VSCoq user interface
    lifecycle: ide
  - name: coq-aac-tactics.8.20.0
    source: https://github.com/rocq-community/aac-tactics
    license: https://spdx.org/licenses/LGPL-3.0-or-later.html
    synopsis:  Coq tactics for rewriting universally quantified equations, modulo associative (and possibly commutative and idempotent) operators
    description: >
      This Coq plugin provides tactics for rewriting and proving universallyquantified equations modulo associativity and commutativity of some operator,with idempotent commutative operators enabling additional simplifications.The tactics can be applied for custom operators by registering the operators andtheir properties as type class instances. Instances for many commonly used operators,such as for binary integer arithmetic and booleans, are provided with the plugin.
    lifecycle: full
  - name: coq-bignums.9.0.0+coq8.20
    source: https://github.com/rocq-community/bignums
    license: https://spdx.org/licenses/LGPL-2.1-only.html
    synopsis:  Bignums, the Coq library of arbitrarily large numbers
    description: >
      This Coq library provides BigN, BigZ, and BigQ that used tobe part of the standard library.
    lifecycle: full
  - name: coq-coqeal.2.0.3
    source: https://github.com/rocq-community/coqeal
    license: https://spdx.org/licenses/MIT.html
    synopsis:  CoqEAL - The Coq Effective Algebra Library
    description: >
      This Coq library contains a subset of the work that was developed in the contextof the ForMath EU FP7 project (2009-2013). It has two parts:- theory, which contains developments in algebra including normal forms of matrices,  and optimized algorithms on MathComp data structures.- refinements, which is a framework to ease change of data representations during a proof.
    lifecycle: full
  - name: coq-coqprime-generator.1.1.2
    source: https://github.com/thery/coqprime
    license: https://spdx.org/licenses/LGPL-2.1-only.html
    synopsis:  Certificate generator for prime numbers in Coq
    description: >
      
    lifecycle: full
  - name: coq-coqprime.1.6.0
    source: https://github.com/thery/coqprime
    license: https://spdx.org/licenses/LGPL-2.1-only.html
    synopsis:  Certifying prime numbers in Coq
    description: >
      
    lifecycle: full
  - name: coq-coquelicot.3.4.2
    source: http://coquelicot.saclay.inria.fr/" rel="nofollow
    license: https://spdx.org/licenses/LGPL-3.0-or-later.html
    synopsis:  A Coq formalization of real analysis compatible with the standard library
    description: >
      
    lifecycle: full
  - name: coq-corn.8.20.0
    source: https://github.com/rocq-community/corn
    license: https://spdx.org/licenses/GPL-2.0.html
    synopsis:  The Coq Constructive Repository at Nijmegen
    description: >
      CoRN includes the following parts:- Algebraic Hierarchy  An axiomatic formalization of the most common algebraic  structures, including setoids, monoids, groups, rings,  fields, ordered fields, rings of polynomials, real and  complex numbers- Model of the Real Numbers  Construction of a concrete real number structure  satisfying the previously defined axioms- Fundamental Theorem of Algebra  A proof that every non-constant polynomial on the complex  plane has at least one root- Real Calculus  A collection of elementary results on real analysis,  including continuity, differentiability, integration,  Taylor'apos;s theorem and the Fundamental Theorem of Calculus- Exact Real Computation  Fast verified computation inside Coq. This includes: real numbers, functions,  integrals, graphs of functions, differential equations.
    lifecycle: full
  - name: coq-dpdgraph.1.0+8.20
    source: https://github.com/rocq-community/coq-dpdgraph
    license: https://spdx.org/licenses/LGPL-2.1-only.html
    synopsis:  Compute dependencies between Coq objects (definitions, theorems) and produce graphs
    description: >
      Coq plugin that extracts the dependencies between Coq objects,and produces files with dependency information. Includes toolsto visualize dependency graphs and find unused definitions.
    lifecycle: full
  - name: coq-elpi.2.3.0
    source: https://github.com/LPCIC/coq-elpi
    license: https://spdx.org/licenses/LGPL-2.1-or-later.html
    synopsis:  Elpi extension language for Coq
    description: >
      Coq-elpi provides a Coq plugin that embeds ELPI. It also provides a way to embed Coq'apos;s terms into λProlog using the Higher-Order Abstract Syntax approach and a way to read terms back. In addition to that it exports to ELPI a set of Coq'apos;s primitives, e.g. printing a message, accessing the environment of theorems and data types, defining a new constant and so on. For convenience it also provides a quotation and anti-quotation for Coq'apos;s syntax in λProlog. E.g., `{{nat}}` is expanded to the type name of natural numbers, or `{{A -&gt;gt; B}}` to the representation of a product by unfolding the `-&gt;gt;` notation. Finally it provides a way to define new vernacular commands and new tactics.
    lifecycle: full
  - name: coq-equations.1.3.1+8.20
    source: https://mattam82.github.io/Coq-Equations" rel="nofollow
    license: https://spdx.org/licenses/LGPL-2.1-only.html
    synopsis:  A function definition package for Coq
    description: >
      Equations is a function definition plugin for Coq, that allows thedefinition of functions by dependent pattern-matching and well-founded,mutual or nested structural recursion and compiles them into coreterms. It automatically derives the clauses equations, the graph of thefunction and its associated elimination principle.
    lifecycle: full
  - name: coq-ext-lib.0.13.0
    source: https://github.com/rocq-community/coq-ext-lib
    license: https://spdx.org/licenses/BSD-2-Clause.html
    synopsis:  A library of Coq definitions, theorems, and tactics
    description: >
      A collection of theories and plugins that may be useful in other Coq developments.
    lifecycle: full
  - name: coq-flocq.4.2.0
    source: https://flocq.gitlabpages.inria.fr/" rel="nofollow
    license: https://spdx.org/licenses/LGPL-3.0-or-later.html
    synopsis:  A formalization of floating-point arithmetic for the Coq system
    description: >
      
    lifecycle: full
  - name: coq-gappa.1.5.5
    source: https://gappa.gitlabpages.inria.fr/" rel="nofollow
    license: https://spdx.org/licenses/LGPL-3.0-or-later.html
    synopsis:  A Coq tactic for discharging goals about floating-point arithmetic and round-off errors using the Gappa prover
    description: >
      
    lifecycle: full
  - name: coq-hammer-tactics.1.3.2+8.20
    source: https://github.com/lukaszcz/coqhammer
    license: https://spdx.org/licenses/LGPL-2.1-only.html
    synopsis:  Reconstruction tactics for the hammer for Coq
    description: >
      Collection of tactics that are used by the hammer for Coqto reconstruct proofs found by automated theorem provers. When the hammerhas been successfully applied to a project, only this package needsto be installed; the hammer plugin is not required.
    lifecycle: full
  - name: coq-hammer.1.3.2+8.20
    source: https://github.com/lukaszcz/coqhammer
    license: https://spdx.org/licenses/LGPL-2.1-only.html
    synopsis:  General-purpose automated reasoning hammer tool for Coq
    description: >
      A general-purpose automated reasoning hammer tool for Coq that combineslearning from previous proofs with the translation of problems to thelogics of automated systems and the reconstruction of successfully found proofs.
    lifecycle: full
  - name: coq-hierarchy-builder.1.8.0
    source: https://github.com/math-comp/hierarchy-builder
    license: https://spdx.org/licenses/MIT.html
    synopsis:  High level commands to declare and evolve a hierarchy based on packed classes
    description: >
      Hierarchy Builder is a high level language to build hierarchies of algebraic structures and make thesehierarchies evolve without breaking user code. The key concepts are the ones of factory, builderand abbreviation that let the hierarchy developer describe an actual interface for their library.Behind that interface the developer can provide appropriate code to ensure retro compatibility.
    lifecycle: full
  - name: coq-hott.8.20
    source: http://homotopytypetheory.org/" rel="nofollow
    license: https://spdx.org/licenses/BSD-2-Clause.html
    synopsis:  The Homotopy Type Theory library
    description: >
      To use the HoTT library, the following flags must be passed to coqc:  -noinit -indices-matterTo use the HoTT library in a project, add the following to _CoqProject:  -arg -noinit  -arg -indices-matter
    lifecycle: full
  - name: coq-interval.4.11.1
    source: https://coqinterval.gitlabpages.inria.fr/" rel="nofollow
    license: https://spdx.org/licenses/CECILL-C.html
    synopsis:  A Coq tactic for proving bounds on real-valued expressions automatically
    description: >
      
    lifecycle: full
  - name: coq-iris-heap-lang.4.3.0
    source: https://iris-project.org/" rel="nofollow
    license: https://spdx.org/licenses/BSD-3-Clause.html
    synopsis:  The canonical example language for Iris
    description: >
      This package defines HeapLang, a concurrent lambda calculus with references, anduses Iris to build a program logic for HeapLang programs.
    lifecycle: full
  - name: coq-iris.4.3.0
    source: https://iris-project.org/" rel="nofollow
    license: https://spdx.org/licenses/BSD-3-Clause.html
    synopsis:  A Higher-Order Concurrent Separation Logic Framework with support for interactive proofs
    description: >
      Iris is a framework for reasoning about the safety of concurrent programs usingconcurrent separation logic. It can be used to develop a program logic, fordefining logical relations, and for reasoning about type systems, among otherapplications. This package includes the base logic, Iris Proof Mode (IPM) /MoSeL, and a general language-independent program logic; see coq-iris-heap-langfor an instantiation of the program logic to a particular programming language.
    lifecycle: full
  - name: coq-itauto.8.20.0
    source: https://gitlab.inria.fr/fbesson/itauto" rel="nofollow
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Reflexive SAT solver with Nelson-Oppen support, parameterised by a leaf tactic inside Coq
    description: >
      itauto is a reflexive intuitionistic SAT solver parameterised by a theory module.When run inside Coq, the theory module wraps an arbitrary Coq tactic, e.g., the liasolver for linear arithmetic or the congruence solver for uninterpreted function symbolsand constructors. Using a black-box Nelson-Oppen scheme for combination of theories,itauto also provides an SMT-like tactic for propositional reasoning modulo the solvers forboth arithmetic and function symbols.
    lifecycle: full
  - name: coq-libhyps.3.0.1
    source: https://github.com/Matafou/LibHyps
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Hypotheses manipulation library
    description: >
      This library defines a set of tactics to manipulate hypothesisindividually or by group. In particular it allows applying a tactic oneach hypothesis of a goal, or only on *new* hypothesis after sometactic. Examples of manipulations: automatic renaming, subst, revert,or any tactic expecting a hypothesis name as argument.It DOES NOT provide ANYMORE the especialize tactic to ease forwardreasoning by instantianting one, several or all premisses of ahypothesis. Ths is due to coq'apos;s specialize being less permissive aboutevars. This may be fixed in the future.
    lifecycle: full
  - name: coq-math-classes.8.19.0
    source: https://github.com/rocq-community/math-classes
    license: https://spdx.org/licenses/MIT.html
    synopsis:  A library of abstract interfaces for mathematical structures in Coq
    description: >
      Math classes is a library of abstract interfaces for mathematicalstructures, such as:*  Algebraic hierarchy (groups, rings, fields, …)*  Relations, orders, …*  Categories, functors, universal algebra, …*  Numbers: N, Z, Q, …*  Operations, (shift, power, abs, …)It is heavily based on Coq’s new type classes in order to provide:structure inference, multiple inheritance/sharing, convenientalgebraic manipulation (e.g. rewriting) and idiomatic use ofnotations.
    lifecycle: full
  - name: coq-mathcomp-algebra-tactics.1.2.3
    source: https://github.com/math-comp/algebra-tactics
    license: https://spdx.org/licenses/CECILL-B.html
    synopsis:  Ring, field, lra, nra, and psatz tactics for Mathematical Components
    description: >
      This library provides `ring`, `field`, `lra`, `nra`, and `psatz` tactics forthe Mathematical Components library. These tactics use the algebraicstructures defined in the MathComp library and their canonical instances forthe instance resolution, and do not require any special instance declaration,like the `Add Ring` and `Add Field` commands. Therefore, each of these tacticsworks with any instance of the respective structure, including concreteinstances declared through Hierarchy Builder, abstract instances, and mixedconcrete and abstract instances, e.g., `int * R` where `R` is an abstractcommutative ring. Another key feature of Algebra Tactics is that theyautomatically push down ring morphisms and additive functions to leaves ofring/field expressions before applying the proof procedures.
    lifecycle: full
  - name: coq-mathcomp-algebra.2.3.0
    source: https://math-comp.github.io/" rel="nofollow
    license: https://spdx.org/licenses/CECILL-B.html
    synopsis:  Mathematical Components Library on Algebra
    description: >
      This library contains definitions and theorems about discrete(i.e. with decidable equality) algebraic structures : ring, fields,ordered fields, real fields,  modules, algebras, integers, rationalnumbers, polynomials, matrices, vector spaces...
    lifecycle: full
  - name: coq-mathcomp-analysis.1.8.0
    source: https://github.com/math-comp/analysis
    license: https://spdx.org/licenses/CECILL-C.html
    synopsis:  An analysis library for mathematical components
    description: >
      This package contains a library for real analysis forthe Coq proof-assistant and using the Mathematical Components library.
    lifecycle: full
  - name: coq-mathcomp-bigenough.1.0.1
    source: https://github.com/math-comp/bigenough
    license: https://spdx.org/licenses/CECILL-B.html
    synopsis:  A small library to do epsilon - N reasoning
    description: >
      The package contains a package to reasoning with big enough objects(mostly natural numbers). This package is essentially for backwardcompatibility purposes as `bigenough` will be subsumed by the neartactics. The formalization is based on the Mathematical Componentslibrary.
    lifecycle: full
  - name: coq-mathcomp-character.2.3.0
    source: https://math-comp.github.io/" rel="nofollow
    license: https://spdx.org/licenses/CECILL-B.html
    synopsis:  Mathematical Components Library on character theory
    description: >
      This library contains definitions and theorems about grouprepresentations, characters and class functions.
    lifecycle: full
  - name: coq-mathcomp-field.2.3.0
    source: https://math-comp.github.io/" rel="nofollow
    license: https://spdx.org/licenses/CECILL-B.html
    synopsis:  Mathematical Components Library on Fields
    description: >
      This library contains definitions and theorems about field extensions,galois theory, algebraic numbers, cyclotomic polynomials...
    lifecycle: full
  - name: coq-mathcomp-fingroup.2.3.0
    source: https://math-comp.github.io/" rel="nofollow
    license: https://spdx.org/licenses/CECILL-B.html
    synopsis:  Mathematical Components Library on finite groups
    description: >
      This library contains definitions and theorems about finite groups,group quotients, group morphisms, group presentation, group action...
    lifecycle: full
  - name: coq-mathcomp-finmap.2.1.0
    source: https://github.com/math-comp/finmap
    license: https://spdx.org/licenses/CECILL-B.html
    synopsis:  Finite sets, finite maps, finitely supported functions
    description: >
      This library is an extension of mathematical component in order tosupport finite sets and finite maps on choicetypes (rather that finitetypes). This includes support for functions with finite support andmultisets. The library also contains a generic order and set libary,which will be used to subsume notations for finite sets, eventually.
    lifecycle: full
  - name: coq-mathcomp-multinomials.2.3.0
    source: https://github.com/math-comp/multinomials
    license: https://spdx.org/licenses/CECILL-B.html
    synopsis:  A Multivariate polynomial Library for the Mathematical Components Library
    description: >
      
    lifecycle: full
  - name: coq-mathcomp-real-closed.2.0.2
    source: https://github.com/math-comp/real-closed
    license: https://spdx.org/licenses/CECILL-B.html
    synopsis:  Mathematical Components Library on real closed fields
    description: >
      This library contains definitions and theorems about real closedfields, with a construction of the real closure and the algebraicclosure (including a proof of the fundamental theorem ofalgebra). It also contains a proof of decidability of the firstorder theory of real closed field, through quantifier elimination.
    lifecycle: full
  - name: coq-mathcomp-solvable.2.3.0
    source: https://math-comp.github.io/" rel="nofollow
    license: https://spdx.org/licenses/CECILL-B.html
    synopsis:  Mathematical Components Library on finite groups (II)
    description: >
      This library contains more definitions and theorems about finite groups.
    lifecycle: full
  - name: coq-mathcomp-ssreflect.2.3.0
    source: https://math-comp.github.io/" rel="nofollow
    license: https://spdx.org/licenses/CECILL-B.html
    synopsis:  Small Scale Reflection
    description: >
      This library includes the small scale reflection proof languageextension and the minimal set of libraries to take advantage of it.This includes libraries on lists (seq), boolean and booleanpredicates, natural numbers and types with decidable equality,finite types, finite sets, finite functions, finite graphs, basic arithmeticsand prime numbers, big operators
    lifecycle: full
  - name: coq-mathcomp-word.3.2
    source: https://github.com/jasmin-lang/coqword
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Yet Another Coq Library on Machine Words
    description: >
      
    lifecycle: full
  - name: coq-mathcomp-zify.1.5.0+2.0+8.16
    source: https://github.com/math-comp/mczify
    license: https://spdx.org/licenses/CECILL-B.html
    synopsis:  Micromega tactics for Mathematical Components
    description: >
      This small library enables the use of the Micromega arithmetic solvers of Coqfor goals stated with the definitions of the Mathematical Components libraryby extending the zify tactic.
    lifecycle: full
  - name: coq-menhirlib.20240715
    source: https://gitlab.inria.fr/fpottier/coq-menhirlib" rel="nofollow
    license: https://spdx.org/licenses/LGPL-3.0-or-later.html
    synopsis:  A support library for verified Coq parsers produced by Menhir
    description: >
      
    lifecycle: full
  - name: coq-mtac2.1.4+8.20
    source: https://github.com/Mtac2/Mtac2
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Typed tactic language for Coq
    description: >
      
    lifecycle: full
  - name: coq-ott.0.34
    source: http://www.cl.cam.ac.uk/~pes20/ott/" rel="nofollow
    license: https://spdx.org/licenses/BSD-3-Clause.html
    synopsis:  Auxiliary Coq library for Ott, a tool for writing definitions of programming languages and calculi
    description: >
      Ott takes as input a definition of a language syntax and semantics, in a conciseand readable ASCII notation that is close to what one would write in informalmathematics. It can then generate a Coq version of the definition, which requiresthis library.
    lifecycle: full
  - name: coq-paramcoq.1.1.3+coq8.20
    source: https://github.com/rocq-community/paramcoq
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Plugin for generating parametricity statements to perform refinement proofs
    description: >
      A Coq plugin providing commands for generating parametricity statements.Typical applications of such statements are in data refinement proofs.Note that the plugin is still in an experimental state - it is not very userfriendly (lack of good error messages) and still contains bugs. But itis usable enough to \translate\ a large chunk of the standard library.
    lifecycle: full
  - name: coq-quickchick.2.0.5
    source: https://github.com/QuickChick/QuickChick
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Randomized Property-Based Testing for Coq
    description: >
      A library for property-based testing in Coq.  - Combinators for testable properties and random generators.  - QuickChick plugin for running tests in a Coq session.  - Includes a mutation testing tool.
    lifecycle: full
  - name: coq-reglang.1.2.1
    source: https://github.com/rocq-community/reglang
    license: https://spdx.org/licenses/CECILL-B.html
    synopsis:  Representations of regular languages (i.e., regexps, various types of automata, and WS1S) with equivalence proofs, in Coq and MathComp
    description: >
      This library provides definitions and verified translations betweendifferent representations of regular languages: various forms ofautomata (deterministic, nondeterministic, one-way, two-way),regular expressions, and the logic WS1S. It also contains variousdecidability results and closure properties of regular languages.
    lifecycle: full
  - name: coq-relation-algebra.1.7.11
    source: http://perso.ens-lyon.fr/damien.pous/ra/" rel="nofollow
    license: https://spdx.org/licenses/LGPL-3.0-or-later.html
    synopsis:  Relation Algebra and KAT in Coq
    description: >
      
    lifecycle: full
  - name: coq-simple-io.1.10.0
    source: https://github.com/Lysxia/coq-simple-io
    license: https://spdx.org/licenses/MIT.html
    synopsis:  IO monad for Coq
    description: >
      This library provides tools to implement IO programs directly in Coq, in asimilar style to Haskell. Facilities for formal verification are not included.IO is defined as a parameter with a purely functional interface in Coq,to be extracted to OCaml. Some wrappers for the basic types and functions inthe OCaml Stdlib module are provided. Users are free to define their ownAPIs on top of this IO type.
    lifecycle: full
  - name: coq-stdpp.1.11.0
    source: https://gitlab.mpi-sws.org/iris/stdpp" rel="nofollow
    license: https://spdx.org/licenses/BSD-3-Clause.html
    synopsis:  An extended \Standard Library\ for Coq
    description: >
      The key features of this library are as follows:- It provides a great number of definitions and lemmas for common data  structures such as lists, finite maps, finite sets, and finite multisets.- It uses type classes for common notations (like `∅`, `∪`, and Haskell-style  monad notations) so that these can be overloaded for different data structures.- It uses type classes to keep track of common properties of types, like it  having decidable equality or being countable or finite.- Most data structures are represented in canonical ways so that Leibniz  equality can be used as much as possible (for example, for maps we have  `m1 = m2` iff `∀ i, m1 !! i = m2 !! i`). On top of that, the library provides  setoid instances for most types and operations.- It provides various tactics for common tasks, like an ssreflect inspired  `done` tactic for finishing trivial goals, a simple breadth-first solver  `naive_solver`, an equality simplifier `simplify_eq`, a solver `solve_proper`  for proving compatibility of functions with respect to relations, and a solver  `set_solver` for goals involving set operations.- It is entirely dependency- and axiom-free.
    lifecycle: full
  - name: coq-unicoq.1.6+8.20
    source: https://github.com/unicoq/unicoq
    license: https://spdx.org/licenses/MIT.html
    synopsis:  An enhanced unification algorithm for Coq
    description: >
      
    lifecycle: full
  - name: eprover.3.1
    source: https://www.eprover.org" rel="nofollow
    license: Unknown
    synopsis:  E Theorem Prover
    description: >
      E is a theorem prover for first-order and higher-order logic with equality. It accepts a problem specification, typically consisting of a number of first-order clauses or formulas, and a conjecture, in clausal or full first-order/higher-order form. The system will then try to find a formal proof for the conjecture, assuming the axioms.
    lifecycle: full
  - name: gappa.1.4.1
    source: https://gitlab.inria.fr/gappa/gappa" rel="nofollow
    license: https://spdx.org/licenses/CECILL-2.1.html
    synopsis:  Tool intended for formally proving properties on numerical programs dealing with floating-point or fixed-point arithmetic
    description: >
      
    lifecycle: full
  - name: menhir.20240715
    source: http://gitlab.inria.fr/fpottier/menhir" rel="nofollow
    license: https://spdx.org/licenses/GPL-2.0-only.html
    synopsis:  An LR(1) parser generator
    description: >
      
    lifecycle: full
  - name: ott.0.34
    source: http://www.cl.cam.ac.uk/~pes20/ott/" rel="nofollow
    license: https://spdx.org/licenses/BSD-3-Clause.html
    synopsis:  A tool for writing definitions of programming languages and calculi
    description: >
      Ott takes as input a definition of a language syntax and semantics, in aconcise and readable ASCII notation that is close to what one would write ininformal mathematics.  It generates output:- a LaTeX source file that defines commands to build a typeset version of the definition;- a Coq version of the definition;- a HOL version of the definition;- an Isabelle/HOL version of the definition;- a Lem version of the definition;- an OCaml version of the syntax of the definition.Additionally, it can be run as a filter, taking aLaTeX/Coq/Isabelle/HOL/Lem/OCaml source filewith embedded (symbolic) terms of the defined language, parsing them andreplacing them by typeset terms.
    lifecycle: full
  - name: sexplib.v0.16.0
    source: https://github.com/janestreet/sexplib
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Library for serializing OCaml values to and from S-expressions
    description: >
      Part of Jane Street'apos;s Core libraryThe Core suite of libraries is an industrial strength alternative toOCaml'apos;s standard library that was developed by Jane Street, thelargest industrial user of OCaml.
    lifecycle: full
  - name: z3_tptp.4.13.0
    source: https://github.com/Z3prover/z3
    license: https://spdx.org/licenses/MIT.html
    synopsis:  TPTP front end for Z3 solver
    description: >
      
    lifecycle: full
  - name: coq-compcert.3.15
    source: https://compcert.org/" rel="nofollow
    license: Unknown
    synopsis:  The CompCert C compiler (64 bit)
    description: >
      
    lifecycle: optional
  - name: coq-unimath.20240923
    source: https://github.com/UniMath/UniMath
    license: Unknown
    synopsis:  Library of Univalent Mathematics
    description: >
      
    lifecycle: optional
  - name: coq-vst.2.15
    source: http://vst.cs.princeton.edu/" rel="nofollow
    license: https://spdx.org/licenses/BSD-2-Clause.html
    synopsis:  Verified Software Toolchain
    description: >
      The software toolchain includes static analyzers to check assertions about your program; optimizing compilers to translate your program to machine language; operating systems and libraries to supply context for your program. The Verified Software Toolchain project assures with machine-checked proofs that the assertions claimed at the top of the toolchain really hold in the machine-language program, running in the operating-system context.
    lifecycle: optional
  - name: coq-bedrock2-compiler.0.0.8
    source: https://github.com/mit-plv/bedrock2
    license: https://spdx.org/licenses/MIT.html
    synopsis:  A work-in-progress language and compiler for verified low-level programming (compiler part)
    description: >
      bedrock2 is a low-level systems programming language. This language isequipped with a simple program logic for proving correctness of theprograms.  This package includes a verified compiler targeting RISC-Vfrom this language.The project has similar goals as bedrock, but uses a different design.No code is shared between bedrock and bedrock2.
    lifecycle: extended
  - name: coq-bedrock2.0.0.8
    source: https://github.com/mit-plv/bedrock2
    license: https://spdx.org/licenses/MIT.html
    synopsis:  A work-in-progress language and compiler for verified low-level programming
    description: >
      bedrock2 is a low-level systems programming language. This language isequipped with a simple program logic for proving correctness of theprograms.  A verified compiler targeting RISC-V from this languageexists in the coq-bedrock2-compiler package on opam.The project has similar goals as bedrock, but uses a different design.No code is shared between bedrock and bedrock2.
    lifecycle: extended
  - name: coq-coqutil.0.0.6
    source: https://github.com/mit-plv/coqutil
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Coq library for tactics, basic definitions, sets, maps
    description: >
      ### coqutil -- Various Coq UtilitiesContents:* [Datatypes](https://github.com/mit-plv/coqutil/tree/master/src/coqutil/Datatypes): Some utilities for existing datatypes, and new datatypes.* [Decidable](https://github.com/mit-plv/coqutil/blob/master/src/coqutil/Decidable.v): `BoolSpec`-based decidability typeclasses. Allows one to write `if MyType_eqb a b then ... else ...` where `MyType_eqb a b` returns a `bool`, instead of writing `if MyType_eq_dec a b then ... else ...` where `MyType_eq_dec a b` returns a `sumbool`, while still getting `a = b` and `a gt; b` as hypotheses (as opposed to `MyType_eqb a b = true` and `MyType_eqb a b = false`) after destructing the `if` (need to use [`destr`](https://github.com/mit-plv/coqutil/blob/master/src/coqutil/Tactics/destr.v) instead of `destruct`). So one gets the benefits of `Sumbool` without getting its disadvantage of having to carry around proof terms, which can cause a blow-up under reduction if one is not careful.* [Map](https://github.com/mit-plv/coqutil/tree/master/src/coqutil/Map): A typeclass based map library allowing one to abstract over the concrete implementation of maps. The implementations have to be extensional, which excludes certain efficient implementations, but simplifies proofs, because one can `replace mapA with mapB` if one can prove that `mapA` and `mapB` have the same contents. Comes with a [solver](https://github.com/mit-plv/coqutil/blob/master/src/coqutil/Map/Solver.v) which works reasonably fast on most map goals we have encountered so far.* [Tactics](https://github.com/mit-plv/coqutil/tree/master/src/coqutil/Tactics): A collection of useful general-purpose tactics.* [Word](https://github.com/mit-plv/coqutil/tree/master/src/coqutil/Word): Fixed width words for any width, in the same typeclass based style as the map library. Designed for the case where all words have the same (potentially abstract) bit width. Therefore, it does not provide functions to concatenate and split words, which is better addressed by [bbv](https://github.com/mit-plv/bbv/).* [Z](https://github.com/mit-plv/coqutil/tree/master/src/coqutil/Z): Utilities to work with the `Z` type from Coq'apos;s standard library, including a tactic to prove `Z` equalities by splitting the equality into equalities on bit index ranges, a tactic to make `lia` capable of reasoning about goals with division and modulo, and a tactic to simplify expressions containing nested occurrences of `mod`, and more misc utilities.* Various macros, notations, and desirable default settings.Each feature is intended to be as minimal and as independent of the other features as possible, so that users can pick just what they need.
    lifecycle: extended
  - name: coq-deriving.0.2.1
    source: https://github.com/arthuraa/deriving
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Generic instances of MathComp classes
    description: >
      Deriving provides generic instances of MathComp classes forinductive data types.  It includes native support for eqType,choiceType, countType and finType instances, and it allows users todefine their own instances for other classes.
    lifecycle: extended
  - name: coq-extructures.0.5.0
    source: https://github.com/arthuraa/extructures
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Finite sets, maps, and other data structures with extensional reasoning
    description: >
      
    lifecycle: extended
  - name: coq-fiat-crypto.0.1.3
    source: https://github.com/mit-plv/fiat-crypto
    license: Unknown
    synopsis:  Cryptographic Primitive Code Generation by Fiat
    description: >
      Coq code and proofs for a command-line binary that can synthesize proven-correctbig-integer modular field arithmetic operations for cryptography.Target languages include C, Rust, Zig, Go, and bedrock2.
    lifecycle: extended
  - name: coq-metacoq.1.3.2+8.20
    source: https://metacoq.github.io/metacoq" rel="nofollow
    license: https://spdx.org/licenses/MIT.html
    synopsis:  A meta-programming framework for Coq
    description: >
      MetaCoq is a meta-programming framework for Coq.The meta-package includes the template-coq library,the PCUIC development including a verified equivalence between Coq and PCUIC,a safe type checker and verified erasure for PCUIC and example translations.See individual packages for more detailed descriptions.
    lifecycle: extended
  - name: coq-record-update.0.3.4
    source: https://github.com/tchajed/coq-record-update
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Generic support for updating record fields in Coq
    description: >
      While Coq provides projections for each field of a record, it has noconvenient way to update a single field of a record. This library provides ageneric way to update a field by name, where the user only has to implement asimple typeclass that lists out the record fields.
    lifecycle: extended
  - name: coq-reduction-effects.0.1.5
    source: https://github.com/rocq-community/reduction-effects
    license: https://spdx.org/licenses/MPL-2.0.html
    synopsis:  A Coq plugin to add reduction side effects to some Coq reduction strategies
    description: >
      
    lifecycle: extended
  - name: coq-rewriter.0.0.12
    source: https://github.com/mit-plv/rewriter
    license: Unknown
    synopsis:  Reflective PHOAS rewriting/pattern-matching-compilation framework for simply-typed equalities and let-lifting, experimental and tailored for use in Fiat Cryptography
    description: >
      
    lifecycle: extended
  - name: coq-riscv.0.0.5
    source: https://github.com/mit-plv/riscv-coq
    license: https://spdx.org/licenses/BSD-3-Clause.html
    synopsis:  RISC-V Specification in Coq, somewhat experimental
    description: >
      
    lifecycle: extended
  - name: coq-rupicola.0.0.10
    source: https://github.com/mit-plv/rupicola
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Gallina to imperative code compilation, currently in design phase
    description: >
      
    lifecycle: extended
  - name: coq-serapi.8.20.0+0.20.0
    source: https://github.com/rocq-archive/coq-serapi
    license: https://spdx.org/licenses/LGPL-2.1-or-later.html
    synopsis:  Serialization library and protocol for machine interaction with the Coq proof assistant
    description: >
      SerAPI is a library for machine-to-machine interaction with theCoq proof assistant, with particular emphasis on applications in IDEs,code analysis tools, and machine learning. SerAPI provides automaticserialization of Coq'apos;s internal OCaml datatypes from/to JSON orS-expressions (sexps).
    lifecycle: extended
  - name: atd.2.16.0
    source: https://github.com/ahrefs/atd
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Parser for the ATD data format description language
    description: >
      ATD is the OCaml library providing a parser for the ATD language and variousutilities. ATD stands for Adjustable Type Definitions in reference to its mainproperty of supporting annotations that allow a good fit with a variety of dataformats. This package also provides the 'apos;atdcat'apos; and 'apos;atddiff'apos; command-lineutilities.
    lifecycle: dependency
  - name: atdgen-runtime.2.16.0
    source: https://github.com/ahrefs/atd
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Runtime library for code generated by atdgen
    description: >
      This package should be used only in conjunction with the atdgen codegenerator
    lifecycle: dependency
  - name: atdgen.2.15.0
    source: https://github.com/ahrefs/atd
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Generates efficient JSON serializers, deserializers and validators
    description: >
      Atdgen is a command-line program that takes as input type definitions in the ATDsyntax and produces OCaml code suitable for data serialization anddeserialization.Two data formats are currently supported, these are biniou and JSON.Atdgen-biniou and Atdgen-json will refer to Atdgen used in one context or theother.Atdgen was designed with efficiency and durability in mind. Software authors areencouraged to use Atdgen directly and to write tools that may reuse part ofAtdgen’s source code.
    lifecycle: dependency
  - name: atdts.2.16.0
    source: https://github.com/ahrefs/atd
    license: https://spdx.org/licenses/MIT.html
    synopsis:  TypeScript code generation for ATD APIs
    description: >
      TypeScript code generation for ATD APIs
    lifecycle: dependency
  - name: base-bigarray.base
    source: /rocq-prover/platform/blob/2025.01.0/doc
    license: Unknown
    synopsis: No synopsis available
    description: >
      Bigarray library distributed with the OCaml compiler
    lifecycle: dependency
  - name: base-threads.base
    source: /rocq-prover/platform/blob/2025.01.0/doc
    license: Unknown
    synopsis: No synopsis available
    description: >
      Threads library distributed with the OCaml compiler
    lifecycle: dependency
  - name: base-unix.base
    source: /rocq-prover/platform/blob/2025.01.0/doc
    license: Unknown
    synopsis: No synopsis available
    description: >
      Unix library distributed with the OCaml compiler
    lifecycle: dependency
  - name: base.v0.16.3
    source: https://github.com/janestreet/base
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Full standard library replacement for OCaml
    description: >
      Full standard library replacement for OCamlBase is a complete and portable alternative to the OCaml standardlibrary. It provides all standard functionalities one would expectfrom a language standard library. It uses consistent conventionsacross all of its module.Base aims to be usable in any context. As a result system dependentfeatures such as I/O are not offered by Base. They are insteadprovided by companion libraries such as stdio:  https://github.com/janestreet/stdio
    lifecycle: dependency
  - name: biniou.1.2.2
    source: https://github.com/mjambon/biniou
    license: https://spdx.org/licenses/BSD-3-Clause.html
    synopsis:  Binary data format designed for speed, safety, ease of use and backward compatibility as protocols evolve
    description: >
      Biniou (pronounced \be new\) is a binary data format designed for speed, safety,ease of use and backward compatibility as protocols evolve. Biniou is vastlyequivalent to JSON in terms of functionality but allows implementations severaltimes faster (4 times faster than yojson), with 25-35% space savings.Biniou data can be decoded into human-readable form without knowledge of typedefinitions except for field and variant names which are represented by 31-bithashes. A program named bdump is provided for routine visualization of binioudata files.The program atdgen is used to derive OCaml-Biniou serializers and deserializersfrom type definitions.Biniou format specification: mjambon.github.io/atdgen-doc/biniou-format.txt
    lifecycle: dependency
  - name: cairo2.0.6.5
    source: https://github.com/Chris00/ocaml-cairo
    license: https://spdx.org/licenses/LGPL-3.0-or-later.html
    synopsis:  Binding to Cairo, a 2D Vector Graphics Library
    description: >
      This is a binding to Cairo, a 2D graphics library with support formultiple output devices. Currently supported output targets includethe X Window System, Quartz, Win32, image buffers, PostScript, PDF,and SVG file output.
    lifecycle: dependency
  - name: camlp-streams.5.0.1
    source: https://github.com/ocaml/camlp-streams
    license: Unknown
    synopsis:  The Stream and Genlex libraries for use with Camlp4 and Camlp5
    description: >
      This package provides two library modules:- Stream: imperative streams, with in-place update and memoization  of the latest element produced.- Genlex: a small parameterized lexical analyzer producing streams  of tokens from streams of characters.The two modules are designed for use with Camlp4 and Camlp5:- The stream patterns and stream expressions of Camlp4/Camlp5 consume  and produce data of type 'apos;a Stream.t.- The Genlex tokenizer can be used as a simple lexical analyzer for  Camlp4/Camlp5-generated parsers.The Stream module can also be used by hand-written recursive-descentparsers, but is not very convenient for this purpose.The Stream and Genlex modules have been part of the OCaml standard libraryfor a long time, and have been distributed as part of the core OCaml system.They will be removed from the OCaml standard library at some future point,but will be maintained and distributed separately in this camlpstreams package.
    lifecycle: dependency
  - name: cmdliner.1.3.0
    source: https://erratique.ch/software/cmdliner" rel="nofollow
    license: https://spdx.org/licenses/ISC.html
    synopsis:  Declarative definition of command line interfaces for OCaml
    description: >
      Cmdliner allows the declarative definition of command line interfacesfor OCaml.It provides a simple and compositional mechanism to convert commandline arguments to OCaml values and pass them to your functions. Themodule automatically handles syntax errors, help messages and UNIX manpage generation. It supports programs with single or multiple commandsand respects most of the [POSIX][1] and [GNU][2] conventions.Cmdliner has no dependencies and is distributed under the ISC license.[1]: http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap12.html[2]: http://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.htmlHome page: http://erratique.ch/software/cmdliner
    lifecycle: dependency
  - name: adwaita-icon-theme.2
    source: https://github.com/GNOME/adwaita-icon-theme
    license: https://spdx.org/licenses/LGPL-3.0-only.html
    synopsis:  Virtual package relying on adwaita-icon-theme
    description: >
      This package can only install if the adwaita-icon-theme package is installed on the system.
    lifecycle: dependency
  - name: autoconf.0.2
    source: http://www.gnu.org/software/autoconf" rel="nofollow
    license: https://spdx.org/licenses/GPL-3.0-only.html
    synopsis:  Virtual package relying on autoconf installation
    description: >
      This package can only install if the autoconf commandis available on the system.
    lifecycle: dependency
  - name: automake.1
    source: https://www.gnu.org/software/automake" rel="nofollow
    license: https://spdx.org/licenses/GPL-2.0-or-later.html
    synopsis:  Virtual package relying on GNU automake
    description: >
      This package can only install if GNU automake is installed on the system.
    lifecycle: dependency
  - name: bash.1
    source: https://www.gnu.org/software/bash/" rel="nofollow
    license: https://spdx.org/licenses/GPL-3.0-or-later.html
    synopsis:  Virtual package to install the Bash shell
    description: >
      This package will install a system bash
    lifecycle: dependency
  - name: bison.2
    source: https://www.gnu.org/software/bison/" rel="nofollow
    license: https://spdx.org/licenses/GPL-3.0-or-later.html
    synopsis:  Virtual package relying on GNU bison
    description: >
      This package can only install if GNU bison is installed on the system.
    lifecycle: dependency
  - name: boost.1
    source: http://www.boost.org" rel="nofollow
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Virtual package relying on boost
    description: >
      This package can only install if the boost library is installed on the system.
    lifecycle: dependency
  - name: c++.1.0
    source: https://github.com/ocaml/opam-repository
    license: https://spdx.org/licenses/GPL-2.0-or-later.html
    synopsis:  Virtual package relying on the c++ compiler
    description: >
      This package can only install if the c++ compiler is installed on the system.
    lifecycle: dependency
  - name: cairo.1
    source: http://cairographics.org/" rel="nofollow
    license: https://spdx.org/licenses/LGPL-2.1-only.html
    synopsis:  Virtual package relying on a Cairo system installation
    description: >
      This package can only install if the cairo lib is installed on the system.
    lifecycle: dependency
  - name: findutils.1
    source: https://www.gnu.org/software/findutils/" rel="nofollow
    license: https://spdx.org/licenses/GPL-3.0-or-later.html
    synopsis:  Virtual package relying on findutils
    description: >
      This package can only install if the findutils binary is installed on the system.
    lifecycle: dependency
  - name: flex.2
    source: https://github.com/westes/flex
    license: https://github.com/westes/flex/blob/master/COPYING
    synopsis:  Virtual package relying on GNU flex
    description: >
      This package can only install if GNU flex is installed on the system.
    lifecycle: dependency
  - name: g++.1.0
    source: https://github.com/ocaml/opam-repository
    license: https://spdx.org/licenses/GPL-2.0-or-later.html
    synopsis:  Virtual package relying on the g++ compiler (for C++)
    description: >
      This package can only install if the g++ compiler is installed on the system.
    lifecycle: dependency
  - name: gcc.1.0
    source: https://github.com/ocaml/opam-repository
    license: https://spdx.org/licenses/GPL-2.0-or-later.html
    synopsis:  Virtual package relying on the gcc compiler (for C)
    description: >
      This package can only install if the gcc compiler is installed on the system.
    lifecycle: dependency
  - name: gmp.4
    source: http://gmplib.org/" rel="nofollow
    license: https://spdx.org/licenses/GPL-1.0-or-later.html
    synopsis:  Virtual package relying on a GMP lib system installation
    description: >
      This package can only install if the GMP lib is installed on the system.
    lifecycle: dependency
  - name: gtk3.18
    source: https://developer.gnome.org/" rel="nofollow
    license: Unknown
    synopsis:  Virtual package relying on GTK+ 3
    description: >
      This package can only install if GTK+ 3 is installed on the system.
    lifecycle: dependency
  - name: gtksourceview3.0+2
    source: https://projects.gnome.org/gtksourceview/" rel="nofollow
    license: https://spdx.org/licenses/LGPL-2.1-or-later.html
    synopsis:  Virtual package relying on a GtkSourceView-3 system installation
    description: >
      This package can only install if libgtksourceview-3.0-dev is installed on the system.
    lifecycle: dependency
  - name: libtool.1
    source: http://www.gnu.org/software/libtool" rel="nofollow
    license: https://spdx.org/licenses/GPL-3.0-only.html
    synopsis:  Virtual package relying on libtool installation
    description: >
      This package can only install if the libtool commandis available on the system.
    lifecycle: dependency
  - name: mpfr.3
    source: http://www.mpfr.org/" rel="nofollow
    license: https://spdx.org/licenses/LGPL-2.0-or-later.html
    synopsis:  Virtual package relying on library MPFR installation
    description: >
      This package can only install if the MPFR library is installed on the system.
    lifecycle: dependency
  - name: pkg-config.4
    source: http://www.freedesktop.org/wiki/Software/pkg-config/" rel="nofollow
    license: https://spdx.org/licenses/GPL-1.0-or-later.html
    synopsis:  Check if pkg-config is installed and create an opam switch local pkgconfig folder
    description: >
      This package can only install if the pkg-config package is installedon the system.
    lifecycle: dependency
  - name: python-3.9.0.0
    source: https://www.python.org/downloads/release/python-3910/" rel="nofollow
    license: Unknown
    synopsis:  Virtual package relying on Python-3 installation
    description: >
      This package can only install if a Python-3 interpreter is availableon the system.If a minor version needs to be specified for your operating system, thenpython-3.9 will be used.
    lifecycle: dependency
  - name: coq-core.8.20.1
    source: https://rocq-prover.org/" rel="nofollow
    license: https://spdx.org/licenses/LGPL-2.1-only.html
    synopsis:  The Coq Proof Assistant -- Core Binaries and Tools
    description: >
      Coq is a formal proof management system. It providesa formal language to write mathematical definitions, executablealgorithms and theorems together with an environment forsemi-interactive development of machine-checked proofs.Typical applications include the certification of properties ofprogramming languages (e.g. the CompCert compiler certificationproject, or the Bedrock verified low-level programming library), theformalization of mathematics (e.g. the full formalization of theFeit-Thompson theorem or homotopy type theory) and teaching.This package includes the Coq core binaries, plugins, and tools, butnot the vernacular standard library.Note that in this setup, Coq needs to be started with the -boot and-noinit options, as will otherwise fail to find the regular Coqprelude, now living in the coq-stdlib package.
    lifecycle: dependency
  - name: coq-mathcomp-classical.1.8.0
    source: https://github.com/math-comp/analysis
    license: https://spdx.org/licenses/CECILL-C.html
    synopsis:  A library for classical logic for mathematical components
    description: >
      This repository contains a library for classical logic forthe Coq proof-assistant and using the Mathematical Components library.
    lifecycle: dependency
  - name: coq-mathcomp-reals.1.8.0
    source: https://github.com/math-comp/analysis
    license: https://spdx.org/licenses/CECILL-C.html
    synopsis:  A library for real numbers for mathematical components
    description: >
      This package contains a library for real numbers forthe Coq proof-assistant and using the Mathematical Components library.
    lifecycle: dependency
  - name: coq-metacoq-common.1.3.2+8.20
    source: https://metacoq.github.io/metacoq" rel="nofollow
    license: https://spdx.org/licenses/MIT.html
    synopsis:  The common library of Template Coq and PCUIC
    description: >
      MetaCoq is a meta-programming framework for Coq.
    lifecycle: dependency
  - name: coq-metacoq-erasure-plugin.1.3.2+8.20
    source: https://metacoq.github.io/metacoq" rel="nofollow
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Implementation and verification of an erasure procedure for Coq
    description: >
      MetaCoq is a meta-programming framework for Coq.The Erasure module provides a complete specification of Coq'apos;s so-called\extraction\ procedure, starting from the PCUIC calculus and targetinguntyped call-by-value lambda-calculus.The `erasure` function translates types and proofs in well-typed termsinto a dummy `tBox` constructor, following closely P. Letouzey'apos;s PhDthesis.
    lifecycle: dependency
  - name: coq-metacoq-erasure.1.3.2+8.20
    source: https://metacoq.github.io/metacoq" rel="nofollow
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Implementation and verification of an erasure procedure for Coq
    description: >
      MetaCoq is a meta-programming framework for Coq.The Erasure module provides a complete specification of Coq'apos;s so-called\extraction\ procedure, starting from the PCUIC calculus and targetinguntyped call-by-value lambda-calculus.The `erasure` function translates types and proofs in well-typed termsinto a dummy `tBox` constructor, following closely P. Letouzey'apos;s PhDthesis.
    lifecycle: dependency
  - name: coq-metacoq-pcuic.1.3.2+8.20
    source: https://metacoq.github.io/metacoq" rel="nofollow
    license: https://spdx.org/licenses/MIT.html
    synopsis:  A type system equivalent to Coq'apos;s and its metatheory
    description: >
      MetaCoq is a meta-programming framework for Coq.The PCUIC module provides a cleaned-up specification of Coq'apos;s typing algorithm alongwith a certified typechecker for it. This module includes the standard metatheory ofPCUIC: Weakening, Substitution, Confluence and Subject Reduction are proven here.
    lifecycle: dependency
  - name: coq-metacoq-quotation.1.3.2+8.20
    source: https://metacoq.github.io/metacoq" rel="nofollow
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Gallina quotation functions for Template Coq
    description: >
      MetaCoq is a meta-programming framework for Coq.The Quotation module is geared at providing functions `□T → □□T` for`□T := Ast.term` (currently implemented) and for `□T := { t : Ast.term&amp; Σ ;;; [] |- t : T }` (still in the works).  Currently `Ast.term →Ast.term` and `(Σ ;;; [] |- t : T) → Ast.term` functions are providedfor Template and PCUIC terms, in `MetaCoq.Quotation.ToTemplate.All`and `MetaCoq.Quotation.ToPCUIC.All`.  Proving well-typedness is stilla work in progress.Ultimately the goal of this development is to prove that `□` is a lax monoidalsemicomonad (a functor with `cojoin : □T → □□T` that codistributes over `unit`and `×`), which is sufficient for proving Löb'apos;s theorem.
    lifecycle: dependency
  - name: coq-metacoq-safechecker-plugin.1.3.2+8.20
    source: https://metacoq.github.io/metacoq" rel="nofollow
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Implementation and verification of an erasure procedure for Coq
    description: >
      MetaCoq is a meta-programming framework for Coq.The Erasure module provides a complete specification of Coq'apos;s so-called\extraction\ procedure, starting from the PCUIC calculus and targetinguntyped call-by-value lambda-calculus.The `erasure` function translates types and proofs in well-typed termsinto a dummy `tBox` constructor, following closely P. Letouzey'apos;s PhDthesis.
    lifecycle: dependency
  - name: coq-metacoq-safechecker.1.3.2+8.20
    source: https://metacoq.github.io/metacoq" rel="nofollow
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Implementation and verification of safe conversion and typechecking algorithms for Coq
    description: >
      MetaCoq is a meta-programming framework for Coq.The SafeChecker modules provides a correct implementation ofweak-head reduction, conversion and typechecking of Coq definitions and global environments.
    lifecycle: dependency
  - name: coq-metacoq-template-pcuic.1.3.2+8.20
    source: https://metacoq.github.io/metacoq" rel="nofollow
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Translations between Template Coq and PCUIC and proofs of correctness
    description: >
      
    lifecycle: dependency
  - name: coq-metacoq-template.1.3.2+8.20
    source: https://metacoq.github.io/metacoq" rel="nofollow
    license: https://spdx.org/licenses/MIT.html
    synopsis:  A quoting and unquoting library for Coq in Coq
    description: >
      MetaCoq is a meta-programming framework for Coq.Template Coq is a quoting library for Coq. It takes Coq terms andconstructs a representation of their syntax tree as a Coq inductive datatype. The representation is based on the kernel'apos;s term representation.In addition to a complete reification and denotation of CIC terms,Template Coq includes:- Reification of the environment structures, for constant and inductive declarations.- Denotation of terms and global declarations- A monad for manipulating global declarations, calling the type  checker, and inserting them in the global environment, in the style of  MetaCoq/MTac.
    lifecycle: dependency
  - name: coq-metacoq-translations.1.3.2+8.20
    source: https://metacoq.github.io/metacoq" rel="nofollow
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Translations built on top of MetaCoq
    description: >
      MetaCoq is a meta-programming framework for Coq.The Translations modules provides implementation of standard translationsfrom type theory to type theory, e.g. parametricity and the `cross-bool`translation that invalidates functional extensionality.
    lifecycle: dependency
  - name: coq-metacoq-utils.1.3.2+8.20
    source: https://metacoq.github.io/metacoq" rel="nofollow
    license: https://spdx.org/licenses/MIT.html
    synopsis:  The utility library of Template Coq and PCUIC
    description: >
      MetaCoq is a meta-programming framework for Coq.
    lifecycle: dependency
  - name: coq-stdlib.8.20.1
    source: https://coq.inria.fr/" rel="nofollow
    license: https://spdx.org/licenses/LGPL-2.1-only.html
    synopsis:  The Coq Proof Assistant -- Standard Library
    description: >
      Coq is a formal proof management system. It providesa formal language to write mathematical definitions, executablealgorithms and theorems together with an environment forsemi-interactive development of machine-checked proofs.Typical applications include the certification of properties ofprogramming languages (e.g. the CompCert compiler certificationproject, or the Bedrock verified low-level programming library), theformalization of mathematics (e.g. the full formalization of theFeit-Thompson theorem or homotopy type theory) and teaching.This package includes the Coq Standard Library, that is to say, theset of modules usually bound to the Coq.* namespace.
    lifecycle: dependency
  - name: coq-vst-zlist.2.13
    source: http://vst.cs.princeton.edu/" rel="nofollow
    license: https://spdx.org/licenses/BSD-2-Clause.html
    synopsis:  A list library indexed by Z type, with a powerful automatic solver
    description: >
      
    lifecycle: dependency
  - name: coqide-server.8.20.1
    source: https://rocq-prover.org/" rel="nofollow
    license: https://spdx.org/licenses/LGPL-2.1-only.html
    synopsis:  The Coq Proof Assistant, XML protocol server
    description: >
      Coq is a formal proof management system. It provides a formal language to write mathematical definitions, executable algorithms and theorems together with an environment for semi-interactive development of machine-checked proofs. This package provides the `coqidetop` language server, an implementation of Coq's [XML protocol](https://github.com/rocq-prover/rocq/blob/master/dev/doc/xml-protocol.md) which allows clients, such as CoqIDE, to interact with Coq in a structured way.
    lifecycle: dependency
  - name: cppo.1.8.0
    source: https://github.com/ocaml-community/cppo
    license: https://spdx.org/licenses/BSD-3-Clause.html
    synopsis:  Code preprocessor like cpp for OCaml
    description: >
      Cppo is an equivalent of the C preprocessor for OCaml programs.It allows the definition of simple macros and file inclusion.Cppo is:* more OCaml-friendly than cpp* easy to learn without consulting a manual* reasonably fast* simple to install and to maintain
    lifecycle: dependency
  - name: csexp.1.5.2
    source: https://github.com/ocaml-dune/csexp
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Parsing and printing of S-expressions in Canonical form
    description: >
      This library provides minimal support for Canonical S-expressions[1]. Canonical S-expressions are a binary encoding of S-expressionsthat is super simple and well suited for communication betweenprograms.This library only provides a few helpers for simple applications. Ifyou need more advanced support, such as parsing from more fancy inputsources, you should consider copying the code of this library givenhow simple parsing S-expressions in canonical form is.To avoid a dependency on a particular S-expression library, the onlymodule of this library is parameterised by the type of S-expressions.[1] https://en.wikipedia.org/wiki/Canonical_S-expressions
    lifecycle: dependency
  - name: easy-format.1.3.4
    source: https://github.com/ocaml-community/easy-format
    license: https://spdx.org/licenses/BSD-3-Clause.html
    synopsis:  High-level and functional interface to the Format module of the OCaml standard library
    description: >
      This module offers a high-level and functional interface to the Format module ofthe OCaml standard library. It is a pretty-printing facility, i.e. it takes asinput some code represented as a tree and formats this code into the mostvisually satisfying result, breaking and indenting lines of code whereappropriate.Input data must be first modelled and converted into a tree using 3 kinds ofnodes:* atoms* lists* labelled nodesAtoms represent any text that is guaranteed to be printed as-is. Lists can modelany sequence of items such as arrays of data or lists of definitions that arelabelled with something like \int main\, \let x =\ or \x:\.
    lifecycle: dependency
  - name: elpi.2.0.6
    source: https://github.com/LPCIC/elpi
    license: https://spdx.org/licenses/LGPL-2.1-or-later.html
    synopsis:  ELPI - Embeddable λProlog Interpreter
    description: >
      ELPI implements a variant of λProlog enriched with Constraint Handling Rules,a programming language well suited to manipulate syntax trees with binders.ELPI is designed to be embedded into larger applications written in OCaml asan extension language. It comes with an API to drive the interpreter and with an FFI for defining built-in predicates and data types, as well asquotations and similar goodies that are handy to adapt the language to the hostapplication.This package provides both a command line interpreter (elpi) and a library tobe linked in other applications (eg by passing -package elpi to ocamlfind).The ELPI programming language has the following features:- Native support for variable binding and substitution, via an Higher Order  Abstract Syntax (HOAS) embedding of the object language. The programmer  does not need to care about technical devices to handle bound variables,  like De Bruijn indices.- Native support for hypothetical context. When moving under a binder one can  attach to the bound variable extra information that is collected when the  variable gets out of scope. For example when writing a type-checker the  programmer needs not to care about managing the typing context.- Native support for higher order unification variables, again via HOAS.  Unification variables of the meta-language (λProlog) can be reused to  represent the unification variables of the object language. The programmer  does not need to care about the unification-variable assignment map and  cannot assign to a unification variable a term containing variables out of  scope, or build a circular assignment.- Native support for syntactic constraints and their meta-level handling rules.  The generative semantics of Prolog can be disabled by turning a goal into a  syntactic constraint (suspended goal). A syntactic constraint is resumed as  soon as relevant variables gets assigned. Syntactic constraints can be  manipulated by constraint handling rules (CHR).- Native support for backtracking. To ease implementation of search.- The constraint store is extensible.  The host application can declare  non-syntactic constraints and use custom constraint solvers to check their  consistency.- Clauses are graftable. The user is free to extend an existing program by  inserting/removing clauses, both at runtime (using implication) and at  \compilation\ time by accumulating files.ELPI is free software released under the terms of LGPL 2.1 or above.
    lifecycle: dependency
  - name: gmp-ecm.7.0.3
    source: https://gitlab.inria.fr/zimmerma/ecm" rel="nofollow
    license: https://spdx.org/licenses/GPL-3.0.html
    synopsis:  GMP-ECM library for the Elliptic Curve Method (ECM) for integer factorization
    description: >
      
    lifecycle: dependency
  - name: jane-street-headers.v0.16.0
    source: https://github.com/janestreet/jane-street-headers
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Jane Street C header files
    description: >
      C header files shared between the various Jane Street packages
    lifecycle: dependency
  - name: jsonrpc.1.22.0
    source: https://github.com/ocaml/ocaml-lsp
    license: https://spdx.org/licenses/ISC.html
    synopsis:  Jsonrpc protocol implemenation
    description: >
      See https://www.jsonrpc.org/specification
    lifecycle: dependency
  - name: jst-config.v0.16.0
    source: https://github.com/janestreet/jst-config
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Compile-time configuration for Jane Street libraries
    description: >
      Defines compile-time constants used in Jane Street libraries such as Base, Core, andAsync.This package has an unstable interface; it is intended only to share configuration betweendifferent packages from Jane Street. Future updates may not be backward-compatible, and wedo not recommend using this package directly.
    lifecycle: dependency
  - name: lablgtk3-sourceview3.3.1.5
    source: https://github.com/garrigue/lablgtk
    license: Unknown
    synopsis:  OCaml interface to GTK+ gtksourceview library
    description: >
      OCaml interface to GTK+3, gtksourceview3 library.See https://garrigue.github.io/lablgtk/ for more information.
    lifecycle: dependency
  - name: lablgtk3.3.1.5
    source: https://github.com/garrigue/lablgtk
    license: Unknown
    synopsis:  OCaml interface to GTK+3
    description: >
      OCaml interface to GTK+3See https://garrigue.github.io/lablgtk/ for more information.
    lifecycle: dependency
  - name: lsp.1.22.0
    source: https://github.com/ocaml/ocaml-lsp
    license: https://spdx.org/licenses/ISC.html
    synopsis:  LSP protocol implementation in OCaml
    description: >
      Implementation of the LSP protocol in OCaml. It is designed to be as portable aspossible and does not make any assumptions about IO.
    lifecycle: dependency
  - name: menhirCST.20240715
    source: http://gitlab.inria.fr/fpottier/menhir" rel="nofollow
    license: Unknown
    synopsis:  Runtime support library for parsers generated by Menhir
    description: >
      
    lifecycle: dependency
  - name: menhirLib.20240715
    source: http://gitlab.inria.fr/fpottier/menhir" rel="nofollow
    license: Unknown
    synopsis:  Runtime support library for parsers generated by Menhir
    description: >
      
    lifecycle: dependency
  - name: menhirSdk.20240715
    source: http://gitlab.inria.fr/fpottier/menhir" rel="nofollow
    license: Unknown
    synopsis:  Compile-time library for auxiliary tools related to Menhir
    description: >
      
    lifecycle: dependency
  - name: num.1.5-1
    source: https://github.com/ocaml/num/
    license: Unknown
    synopsis:  The legacy Num library for arbitrary-precision integer and rational arithmetic
    description: >
      
    lifecycle: dependency
  - name: ocaml-compiler-libs.v0.12.4
    source: https://github.com/janestreet/ocaml-compiler-libs
    license: https://spdx.org/licenses/MIT.html
    synopsis:  OCaml compiler libraries repackaged
    description: >
      This packages exposes the OCaml compiler libraries repackages underthe toplevel names Ocaml_common, Ocaml_bytecomp, Ocaml_optcomp, ...
    lifecycle: dependency
  - name: ocaml-config.2
    source: https://opam.ocaml.org/" rel="nofollow
    license: https://spdx.org/licenses/ISC.html
    synopsis:  OCaml Switch Configuration
    description: >
      This package is used by the OCaml package to set-up its variables.
    lifecycle: dependency
  - name: ocaml-option-flambda.1
    source: https://opam.ocaml.org" rel="nofollow
    license: Unknown
    synopsis:  Set OCaml to be compiled with flambda activated
    description: >
      
    lifecycle: dependency
  - name: ocaml-variants.4.14.2+options
    source: https://ocaml.org" rel="nofollow
    license: Unknown
    synopsis:  Official release of OCaml 4.14.2
    description: >
      
    lifecycle: dependency
  - name: ocaml.4.14.2
    source: https://ocaml.org" rel="nofollow
    license: Unknown
    synopsis:  The OCaml compiler (virtual package)
    description: >
      This package requires a matching implementation of OCaml,and polls it to initialise specific variables like `ocaml:native-dynlink`
    lifecycle: dependency
  - name: ocamlbuild.0.15.0
    source: https://github.com/ocaml/ocamlbuild/
    license: Unknown
    synopsis:  OCamlbuild is a build system with builtin rules to easily build most OCaml projects
    description: >
      
    lifecycle: dependency
  - name: ocamlfind.1.9.5~relocatable
    source: http://projects.camlcity.org/projects/findlib.html" rel="nofollow
    license: https://spdx.org/licenses/MIT.html
    synopsis:  A library manager for OCaml
    description: >
      Findlib is a library manager for OCaml. It provides a convention howto store libraries, and a file format (\META\) to describe theproperties of libraries. There is also a tool (ocamlfind) forinterpreting the META files, so that it is very easy to use librariesin programs and scripts.
    lifecycle: dependency
  - name: ocamlgraph.2.1.0
    source: https://github.com/backtracking/ocamlgraph/
    license: https://spdx.org/licenses/LGPL-2.1-only.html
    synopsis:  A generic graph library for OCaml
    description: >
      Provides both graph data structures and graph algorithms
    lifecycle: dependency
  - name: octavius.1.2.2
    source: https://github.com/ocaml-doc/octavius
    license: https://spdx.org/licenses/ISC.html
    synopsis:  Ocamldoc comment syntax parser
    description: >
      Octavius is a library to parse the `ocamldoc` comment syntax.
    lifecycle: dependency
  - name: parsexp.v0.16.0
    source: https://github.com/janestreet/parsexp
    license: https://spdx.org/licenses/MIT.html
    synopsis:  S-expression parsing library
    description: >
      This library provides generic parsers for parsing S-expressions fromstrings or other medium.The library is focused on performances but still provide full genericparsers that can be used with strings, bigstrings, lexing buffers,character streams or any other sources effortlessly.It provides three different class of parsers:- the normal parsers, producing [Sexp.t] or [Sexp.t list] values- the parsers with positions, building compact position sequences so  that one can recover original positions in order to report properly  located errors at little cost- the Concrete Syntax Tree parsers, produce values of type  [Parsexp.Cst.t] which record the concrete layout of the s-expression  syntax, including commentsThis library is portable and doesn'apos;t provide IO functions. To reads-expressions from files or other external sources, you should useparsexp_io.
    lifecycle: dependency
  - name: ppx_assert.v0.16.0
    source: https://github.com/janestreet/ppx_assert
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Assert-like extension nodes that raise useful errors on failure
    description: >
      Part of the Jane Street'apos;s PPX rewriters collection.
    lifecycle: dependency
  - name: ppx_base.v0.16.0
    source: https://github.com/janestreet/ppx_base
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Base set of ppx rewriters
    description: >
      ppx_base is the set of ppx rewriters used for Base.Note that Base doesn'apos;t need ppx to build, it is only used as averification tool.
    lifecycle: dependency
  - name: ppx_cold.v0.16.0
    source: https://github.com/janestreet/ppx_cold
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Expands [@cold] into [@inline never][@specialise never][@local never]
    description: >
      Part of the Jane Street'apos;s PPX rewriters collection.
    lifecycle: dependency
  - name: ppx_compare.v0.16.0
    source: https://github.com/janestreet/ppx_compare
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Generation of comparison functions from types
    description: >
      Part of the Jane Street'apos;s PPX rewriters collection.
    lifecycle: dependency
  - name: ppx_derivers.1.2.1
    source: https://github.com/ocaml-ppx/ppx_derivers
    license: https://spdx.org/licenses/BSD-3-Clause.html
    synopsis:  Shared  plugin registry
    description: >
      Ppx_derivers is a tiny package whose sole purpose is to allowppx_deriving and ppx_type_conv to inter-operate gracefully when linkedas part of the same ocaml-migrate-parsetree driver.
    lifecycle: dependency
  - name: ppx_deriving.6.0.3
    source: https://github.com/ocaml-ppx/ppx_deriving
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Type-driven code generation for OCaml
    description: >
      ppx_deriving provides common infrastructure for generatingcode based on type definitions, and a set of useful pluginsfor common tasks.
    lifecycle: dependency
  - name: ppx_deriving_yojson.3.9.1
    source: https://github.com/ocaml-ppx/ppx_deriving_yojson
    license: https://spdx.org/licenses/MIT.html
    synopsis:  JSON codec generator for OCaml
    description: >
      ppx_deriving_yojson is a ppx_deriving plugin that providesa JSON codec generator.
    lifecycle: dependency
  - name: ppx_enumerate.v0.16.0
    source: https://github.com/janestreet/ppx_enumerate
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Generate a list containing all values of a finite type
    description: >
      Part of the Jane Street'apos;s PPX rewriters collection.
    lifecycle: dependency
  - name: ppx_globalize.v0.16.0
    source: https://github.com/janestreet/ppx_globalize
    license: https://spdx.org/licenses/MIT.html
    synopsis:  A ppx rewriter that generates functions to copy local values to the global heap
    description: >
      Part of the Jane Street'apos;s PPX rewriters collection.
    lifecycle: dependency
  - name: ppx_hash.v0.16.0
    source: https://github.com/janestreet/ppx_hash
    license: https://spdx.org/licenses/MIT.html
    synopsis:  A ppx rewriter that generates hash functions from type expressions and definitions
    description: >
      Part of the Jane Street'apos;s PPX rewriters collection.
    lifecycle: dependency
  - name: ppx_here.v0.16.0
    source: https://github.com/janestreet/ppx_here
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Expands [%here] into its location
    description: >
      Part of the Jane Street'apos;s PPX rewriters collection.
    lifecycle: dependency
  - name: ppx_import.1.11.0
    source: https://github.com/ocaml-ppx/ppx_import
    license: https://spdx.org/licenses/MIT.html
    synopsis:  A syntax extension for importing declarations from interface files
    description: >
      
    lifecycle: dependency
  - name: ppx_inline_test.v0.16.1
    source: https://github.com/janestreet/ppx_inline_test
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Syntax extension for writing in-line tests in ocaml code
    description: >
      Part of the Jane Street'apos;s PPX rewriters collection.
    lifecycle: dependency
  - name: ppx_js_style.v0.16.0
    source: https://github.com/janestreet/ppx_js_style
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Code style checker for Jane Street Packages
    description: >
      Part of the Jane Street'apos;s PPX rewriters collection.This packages is a no-op ppx rewriter. It is used as a 'apos;lint'apos; tool toenforce some coding conventions across all Jane Street packages.
    lifecycle: dependency
  - name: ppx_optcomp.v0.16.0
    source: https://github.com/janestreet/ppx_optcomp
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Optional compilation for OCaml
    description: >
      Part of the Jane Street'apos;s PPX rewriters collection.
    lifecycle: dependency
  - name: ppx_sexp_conv.v0.16.0
    source: https://github.com/janestreet/ppx_sexp_conv
    license: https://spdx.org/licenses/MIT.html
    synopsis:   plugin to generate S-expression conversion functions
    description: >
      Part of the Jane Street'apos;s PPX rewriters collection.
    lifecycle: dependency
  - name: ppx_yojson_conv.v0.16.0
    source: https://github.com/janestreet/ppx_yojson_conv
    license: https://spdx.org/licenses/MIT.html
    synopsis:   plugin to generate Yojson conversion functions
    description: >
      Part of the Jane Street'apos;s PPX rewriters collection.
    lifecycle: dependency
  - name: ppx_yojson_conv_lib.v0.16.0
    source: https://github.com/janestreet/ppx_yojson_conv_lib
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Runtime lib for ppx_yojson_conv
    description: >
      Part of the Jane Street'apos;s PPX rewriters collection.
    lifecycle: dependency
  - name: ppxlib.0.34.0
    source: https://github.com/ocaml-ppx/ppxlib
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Standard infrastructure for ppx rewriters
    description: >
      Ppxlib is the standard infrastructure for ppx rewritersand other programs that manipulate the in-memory representation ofOCaml programs, a.k.a the \Parsetree\.It also comes bundled with two ppx rewriters that are commonly used towrite tools that manipulate and/or generate Parsetree values;`ppxlib.metaquot` which allows to construct Parsetree values using theOCaml syntax directly and `ppxlib.traverse` which provides variousways of automatically traversing values of a given type, in particularallowing to inject a complex structured value into generated code.
    lifecycle: dependency
  - name: re.1.12.0
    source: https://github.com/ocaml/ocaml-re
    license: Unknown
    synopsis:  RE is a regular expression library for OCaml
    description: >
      Pure OCaml regular expressions with:* Perl-style regular expressions (module Re.Perl)* Posix extended regular expressions (module Re.Posix)* Emacs-style regular expressions (module Re.Emacs)* Shell-style file globbing (module Re.Glob)* Compatibility layer for OCaml'apos;s built-in Str module (module Re.Str)
    lifecycle: dependency
  - name: result.1.5
    source: https://github.com/janestreet/result
    license: https://spdx.org/licenses/BSD-3-Clause.html
    synopsis:  Compatibility Result module
    description: >
      Projects that want to use the new result type defined in OCaml &gt;gt;= 4.03while staying compatible with older version of OCaml should use theResult module defined in this library.
    lifecycle: dependency
  - name: sel.0.5.0
    source: https://github.com/gares/sel
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Simple Event Library
    description: >
      This library is the result of our experience in using threads and the Lwt async monad to tame the problem of writing a server which has to listen and react to multiple sources of events. The library itself is just sugar atop Unix.select. You can read more about the library on https://github.com/gares/sel
    lifecycle: dependency
  - name: seq.base
    source: /rocq-prover/platform/blob/2025.01.0/doc
    license: Unknown
    synopsis:  Compatibility package for OCaml'apos;s standard iterator type starting from 4.07.
    description: >
      
    lifecycle: dependency
  - name: sexplib0.v0.16.0
    source: https://github.com/janestreet/sexplib0
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Library containing the definition of S-expressions and some base converters
    description: >
      Part of Jane Street'apos;s Core libraryThe Core suite of libraries is an industrial strength alternative toOCaml'apos;s standard library that was developed by Jane Street, thelargest industrial user of OCaml.
    lifecycle: dependency
  - name: stdio.v0.16.0
    source: https://github.com/janestreet/stdio
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Standard IO library for OCaml
    description: >
      Stdio implements simple input/output functionalities for OCaml.It re-exports the input/output functions of the OCaml standardlibraries using a more consistent API.
    lifecycle: dependency
  - name: stdlib-shims.0.3.0
    source: https://github.com/ocaml/stdlib-shims
    license: Unknown
    synopsis:  Backport some of the new stdlib features to older compiler
    description: >
      Backport some of the new stdlib features to older compiler,such as the Stdlib module.This allows projects that require compatibility with older compiler touse these new features in their code.
    lifecycle: dependency
  - name: time_now.v0.16.0
    source: https://github.com/janestreet/time_now
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Reports the current time
    description: >
      Provides a single function to report the current time in nanosecondssince the start of the Unix epoch.
    lifecycle: dependency
  - name: topkg.1.0.7
    source: https://erratique.ch/software/topkg" rel="nofollow
    license: https://spdx.org/licenses/ISC.html
    synopsis:  The transitory OCaml software packager
    description: >
      Topkg is a packager for distributing OCaml software. It provides anAPI to describe the files a package installs in a given buildconfiguration and to specify information about the package'apos;sdistribution, creation and publication procedures.The optional topkg-care package provides the `topkg` command line toolwhich helps with various aspects of a package'apos;s life cycle: creatingand linting a distribution, releasing it on the WWW, publish itsdocumentation, add it to the OCaml opam repository, etc.Topkg is distributed under the ISC license and has **no**dependencies. This is what your packages will need as a *build*dependency.Topkg-care is distributed under the ISC license it depends on[fmt][fmt], [logs][logs], [bos][bos], [cmdliner][cmdliner],[webbrowser][webbrowser] and `opam-format`.[fmt]: http://erratique.ch/software/fmt[logs]: http://erratique.ch/software/logs[bos]: http://erratique.ch/software/bos[cmdliner]: http://erratique.ch/software/cmdliner[webbrowser]: http://erratique.ch/software/webbrowserHome page: http://erratique.ch/software/topkg
    lifecycle: dependency
  - name: uutf.1.0.3
    source: https://erratique.ch/software/uutf" rel="nofollow
    license: https://spdx.org/licenses/ISC.html
    synopsis:  Non-blocking streaming Unicode codec for OCaml
    description: >
      Uutf is a non-blocking streaming codec to decode and encode the UTF-8,UTF-16, UTF-16LE and UTF-16BE encoding schemes. It can efficientlywork character by character without blocking on IO. Decoders performcharacter position tracking and support newline normalization.Functions are also provided to fold over the characters of UTF encodedOCaml string values and to directly encode characters in OCamlBuffer.t values. **Note** that since OCaml 4.14, that functionalitycan be found in the Stdlib and you are encouraged to migrate to it.Uutf has no dependency and is distributed under the ISC license.Home page: http://erratique.ch/software/uutf  Contact: Daniel Bünzli `gt;`
    lifecycle: dependency
  - name: yojson.2.2.2
    source: https://github.com/ocaml-community/yojson
    license: https://spdx.org/licenses/BSD-3-Clause.html
    synopsis:  Yojson is an optimized parsing and printing library for the JSON format
    description: >
      Yojson is an optimized parsing and printing library for the JSON format.ydump is a pretty-printing command-line program provided with theyojson package.
    lifecycle: dependency
  - name: z3.4.13.0-3
    source: https://github.com/Z3prover/z3
    license: https://spdx.org/licenses/MIT.html
    synopsis:  Z3 solver
    description: >
      
    lifecycle: dependency
  - name: zarith.1.14
    source: https://github.com/ocaml/Zarith
    license: Unknown
    synopsis:  Implements arithmetic and logical operations over arbitrary-precision integers
    description: >
      The Zarith library implements arithmetic and logical operations overarbitrary-precision integers. It uses GMP to efficiently implementarithmetic over big integers. Small integers are represented as Camlunboxed integers, for speed and space economy.
    lifecycle: dependency
